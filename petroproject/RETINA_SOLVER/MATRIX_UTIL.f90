!****************************************************************************************************************!
!*                                                                                                              *!    
!*                                               MATRIX UTILITIES                                               *!
!*                                                                                                              *!    
!*                                                                                                              *!    
!****************************************************************************************************************!

    SUBROUTINE PREPARE_WELL_CONDENSE__(CONV_CV_SIZE, W_SIZE, CON_SIZE, MATRIX_C2W_VALS, MATRIX_W_VALS, VECTOR_FLOW_VALS, VECTOR_W_VALS, DOF_WELL_CONNECTIVITY, WELL_DOF_CONNECTIVITY, DOF_WELL_ROW_STARTS, WELL_DOF_ROW_STARTS)
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'PREPARE_WELL_CONDENSE__':: RETINA_SOLVER
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, W_SIZE, CON_SIZE
        DOUBLE PRECISION, DIMENSION(0:9 * CON_SIZE - 1), INTENT(INOUT) :: MATRIX_C2W_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * W_SIZE - 1), INTENT(INOUT) :: MATRIX_W_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(INOUT) :: VECTOR_FLOW_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * W_SIZE - 1), INTENT(IN) :: VECTOR_W_VALS
        INTEGER, DIMENSION(0:CON_SIZE - 1), INTENT(IN) :: DOF_WELL_CONNECTIVITY, WELL_DOF_CONNECTIVITY
        INTEGER, DIMENSION(0:CONV_CV_SIZE), INTENt(IN) :: DOF_WELL_ROW_STARTS
        INTEGER, DIMENSION(0:W_SIZE), INTENT(IN) :: WELL_DOF_ROW_STARTS
        INTEGER :: I, J, J_INDEX, INDEX
        
        !$OMP PARALLEL SHARED(MATRIX_W_VALS, MATRIX_C2W_VALS, VECTOR_FLOW_VALS)
        !$OMP DO SCHEDULE(STATIC) PRIVATE(I, J_INDEX, J, INDEX)
        DO I = 0, W_SIZE - 1
            CALL INV__(MATRIX_W_VALS(9 * I:9 * I + 8))
            DO J_INDEX = WELL_DOF_ROW_STARTS(I), WELL_DOF_ROW_STARTS(I + 1) - 1                
                J = WELL_DOF_CONNECTIVITY(J_INDEX)
                ! ASSUMING EACH CELL CONNECTS TO ONLY ONE WELL AT MOST
                INDEX = DOF_WELL_ROW_STARTS(J)
                CALL COPY_MULT_MM__(MATRIX_C2W_VALS(9 * INDEX:9 * INDEX + 8), MATRIX_W_VALS(9 * I:9 * I + 8), MATRIX_C2W_VALS(9 * INDEX:9 * INDEX + 8), 1.D0)
                CALL MULT_MV__(MATRIX_C2W_VALS(9 * INDEX:9 * INDEX + 8), VECTOR_W_VALS(3 * I:3 * I + 2), VECTOR_FLOW_VALS(3 * J:3 * J + 2), -1.D0, 0, 0)
            END DO
        END DO
        !$OMP END DO
        !$OMP END PARALLEL
    END SUBROUTINE
        
     SUBROUTINE AIM_CONDENSE_MATRIX_ON_FRACTURE__(CONV_CV_SIZE, ACTIVE_SIZE_DUAL, DOF_SIZE, ACTIVE_DOF_DUAL, MATRIX_FLOW_VALS, DIAG_DOF, MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, MATRIX_F2M_VALS, VECTOR_MATRIX, VECTOR_FRACTURE, IMPLICITNESS, NATURAL_ID)
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'AIM_CONDENSE_MATRIX_ON_FRACTURE__':: RETINA_SOLVER
        USE OMP_LIB    
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, ACTIVE_SIZE_DUAL, DOF_SIZE
        INTEGER, DIMENSION(0: ACTIVE_SIZE_DUAL - 1), INTENT(IN) :: ACTIVE_DOF_DUAL
        INTEGER, DIMENSION(0: CONV_CV_SIZE - 1), INTENT(IN) :: DIAG_DOF
        !FIXME NOTICE ARRAYS WITH CV SIZE SHOULD BE CHECKED 2*CONV_CV_SIZE IS WRONG
        INTEGER, DIMENSION(0: 2*CONV_CV_SIZE - 1), INTENT(IN) :: IMPLICITNESS, NATURAL_ID
        DOUBLE PRECISION, DIMENSION(0:9 * DOF_SIZE - 1), INTENT(INOUT) :: MATRIX_FLOW_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * CONV_CV_SIZE - 1), INTENT(INOUT) :: MATRIX_MATRIX_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * CONV_CV_SIZE - 1), INTENT(IN) :: MATRIX_M2F_VALS, MATRIX_F2M_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(INOUT) :: VECTOR_FRACTURE
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(IN) :: VECTOR_MATRIX
    
        INTEGER :: AI, I, II, C0_MATRIX, C1_MATRIX, C_VECTOR, MIN_F, MIN_M
        DOUBLE PRECISION, DIMENSION(0:8) :: TEMP
    
        !$OMP PARALLEL SHARED(CONV_CV_SIZE, ACTIVE_SIZE_DUAL, ACTIVE_DOF_DUAL, MATRIX_FLOW_VALS, DIAG_DOF, MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, MATRIX_F2M_VALS, VECTOR_MATRIX, VECTOR_FRACTURE)
        !$OMP DO SCHEDULE(STATIC) PRIVATE(AI, I, MIN_F, MIN_M, C0_MATRIX, C_VECTOR, II, C1_MATRIX, TEMP)
        DO AI = 0, ACTIVE_SIZE_DUAL - 1
            I = ACTIVE_DOF_DUAL(AI)
            IF(IMPLICITNESS(NATURAL_ID(I)) .EQ. 1) THEN
                MIN_F = 0
            ELSE
                MIN_F = 2
            END IF
            IF(IMPLICITNESS(NATURAL_ID(I+CONV_CV_SIZE)) .EQ. 1) THEN
                MIN_M= 0 
            ELSE
                MIN_M= 2
            END IF
            C0_MATRIX = 9 * I
            C1_MATRIX = 9 * DIAG_DOF(I)
            C_VECTOR = 3 * I
            IF(IMPLICITNESS(NATURAL_ID(I+ CONV_CV_SIZE)) .EQ. 1) THEN
                CALL INV__(MATRIX_MATRIX_VALS(C0_MATRIX:C0_MATRIX + 8))
            ELSE
                MATRIX_MATRIX_VALS(C0_MATRIX + 8) = 1.D0/ MATRIX_MATRIX_VALS(C0_MATRIX + 8)
            END IF
            !DEC$ SIMD
            DO II = 0, 8
                TEMP(II) = 0.D0
            END DO
            CALL MULT_MM__(MATRIX_F2M_VALS(C0_MATRIX:C0_MATRIX + 8), MATRIX_MATRIX_VALS(C0_MATRIX:C0_MATRIX + 8), TEMP, 1.D0, MIN_F, MIN_M, MIN_M)
            CALL MULT_MV__(TEMP, VECTOR_MATRIX(C_VECTOR:C_VECTOR + 2), VECTOR_FRACTURE(C_VECTOR:C_VECTOR + 2), -1.D0, MIN_F, MIN_M)
            CALL MULT_MM__(TEMP, MATRIX_M2F_VALS(C0_MATRIX:C0_MATRIX + 8), MATRIX_FLOW_VALS(C1_MATRIX:C1_MATRIX + 8), -1.D0, MIN_F, MIN_F, MIN_M)
            
           
        END DO
        
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL
        
    END SUBROUTINE
                                                                                    !
    SUBROUTINE CONDENSE_MATRIX_ON_FRACTURE__(CONV_CV_SIZE, ACTIVE_SIZE_DUAL, DOF_SIZE, ACTIVE_DOF_DUAL, MATRIX_FLOW_VALS, DIAG_DOF, MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, MATRIX_F2M_VALS, VECTOR_MATRIX, VECTOR_FRACTURE)
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'CONDENSE_MATRIX_ON_FRACTURE__':: RETINA_SOLVER
        USE OMP_LIB    
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, ACTIVE_SIZE_DUAL, DOF_SIZE
        INTEGER, DIMENSION(0:ACTIVE_SIZE_DUAL - 1), INTENT(IN) :: ACTIVE_DOF_DUAL
        INTEGER, DIMENSION(0:CONV_CV_SIZE - 1), INTENT(IN) :: DIAG_DOF
        DOUBLE PRECISION, DIMENSION(0:9 * DOF_SIZE - 1), INTENT(INOUT) :: MATRIX_FLOW_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * CONV_CV_SIZE - 1), INTENT(INOUT) :: MATRIX_MATRIX_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * CONV_CV_SIZE - 1), INTENT(IN) :: MATRIX_M2F_VALS, MATRIX_F2M_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(INOUT) :: VECTOR_FRACTURE
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(IN) :: VECTOR_MATRIX
    
        INTEGER :: AI, I, II, C0_MATRIX, C1_MATRIX, C_VECTOR
        DOUBLE PRECISION, DIMENSION(0:8) :: TEMP
                                                            !
        !$OMP PARALLEL SHARED(CONV_CV_SIZE, ACTIVE_SIZE_DUAL, ACTIVE_DOF_DUAL, MATRIX_FLOW_VALS, DIAG_DOF, MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, MATRIX_F2M_VALS, VECTOR_MATRIX, VECTOR_FRACTURE)
        !$OMP DO SCHEDULE(STATIC) PRIVATE(AI, I, C0_MATRIX, C_VECTOR, II, C1_MATRIX, TEMP)
        DO AI = 0, ACTIVE_SIZE_DUAL - 1
            I = ACTIVE_DOF_DUAL(AI)
            C0_MATRIX = 9 * I
            C1_MATRIX = 9 * DIAG_DOF(I)
            C_VECTOR = 3 * I
           
            CALL INV__(MATRIX_MATRIX_VALS(C0_MATRIX:C0_MATRIX + 8))
            
            !DEC$ SIMD
            DO II = 0, 8
                TEMP(II) = 0.D0
            END DO
            CALL MULT_MM__(MATRIX_F2M_VALS(C0_MATRIX:C0_MATRIX + 8), MATRIX_MATRIX_VALS(C0_MATRIX:C0_MATRIX + 8), TEMP, 1.D0, 0, 0, 0)
            CALL MULT_MV__(TEMP, VECTOR_MATRIX(C_VECTOR:C_VECTOR + 2), VECTOR_FRACTURE(C_VECTOR:C_VECTOR + 2), -1.D0, 0, 0)
            CALL MULT_MM__(TEMP, MATRIX_M2F_VALS(C0_MATRIX:C0_MATRIX + 8), MATRIX_FLOW_VALS(C1_MATRIX:C1_MATRIX + 8), -1.D0, 0, 0, 0)
        END DO
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL
    END SUBROUTINE
    
    SUBROUTINE CONDENSE_MATRIX_ON_FRACTURE_BLOCK_TO_BLOCK__(CONV_CV_SIZE, ACTIVE_SIZE_DUAL,ACTIVE_DOF, DOF_SIZE, ACTIVE_DOF_DUAL, MATRIX_FLOW_VALS, DIAG_DOF, MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, MATRIX_F2M_VALS, VECTOR_MATRIX, VECTOR_FRACTURE,ROW_START_F2M,F2M_SIZE,MATRIX_ROW_STARTS,MATRIX_CONNECTIVITY,COLUMN_NUM_M2F)
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'CONDENSE_MATRIX_ON_FRACTURE_BLOCK_TO_BLOCK__':: RETINA_SOLVER
        USE OMP_LIB    
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, ACTIVE_SIZE_DUAL, DOF_SIZE,ACTIVE_DOF,F2M_SIZE
        INTEGER, DIMENSION(0:ACTIVE_SIZE_DUAL - 1), INTENT(IN) :: ACTIVE_DOF_DUAL
        INTEGER, DIMENSION(0:ACTIVE_DOF - 1), INTENT(IN) :: DIAG_DOF
        DOUBLE PRECISION, DIMENSION(0:9 * DOF_SIZE - 1), INTENT(INOUT) :: MATRIX_FLOW_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * CONV_CV_SIZE - 1), INTENT(INOUT) :: MATRIX_MATRIX_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * (CONV_CV_SIZE*3) - 1), INTENT(IN) :: MATRIX_M2F_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * F2M_SIZE - 1), INTENT(IN) :: MATRIX_F2M_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * ACTIVE_DOF - 1), INTENT(INOUT) :: VECTOR_FRACTURE
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(IN) :: VECTOR_MATRIX
        INTEGER, DIMENSION(0: ACTIVE_DOF - 1), INTENT(IN) :: ROW_START_F2M 
        INTEGER, DIMENSION(0: ACTIVE_DOF), INTENT(IN) :: MATRIX_ROW_STARTS
        INTEGER, DIMENSION(0: DOF_SIZE-1), INTENT(IN) :: MATRIX_CONNECTIVITY
        INTEGER, DIMENSION(0: (CONV_CV_SIZE*3)-1), INTENT(IN) :: COLUMN_NUM_M2F
        INTEGER :: AI, II
        INTEGER :: C_M2M_MATRIX,C_F2M_FRACTURE_SURRUONDING,C_F2M_FRACTURE_HORIZONTAL,C_F2M_FRACTURE_TOP
        INTEGER :: C_M2F_FRACTURE_SURRUONDING,C_M2F_FRACTURE_HORIZONTAL,C_M2F_FRACTURE_TOP
        INTEGER :: C_F2F_FRACTURE_SURRUONDING_1,C_F2F_FRACTURE_SURRUONDING_2,C_F2F_FRACTURE_SURRUONDING_3
        INTEGER :: C_F2F_FRACTURE_HORIZONTAL_1,C_F2F_FRACTURE_HORIZONTAL_2,C_F2F_FRACTURE_HORIZONTAL_3
        INTEGER :: C_F2F_FRACTURE_TOP_1,C_F2F_FRACTURE_TOP_2,C_F2F_FRACTURE_TOP_3
        INTEGER :: C_VECTOR_MATRIX,C_VECTOR_FRACTURE_SURRUONDING,C_VECTOR_FRACTURE_HORIZONTAL,C_VECTOR_FRACTURE_TOP
        DOUBLE PRECISION, DIMENSION(0:8) :: TEMP,TEMP_TOP_FRACTURE
        INTEGER :: ROW_NUMBER_SURRUONDING,ROW_NUMBER_HORIZONTAL,ROW_NUMBER_TOP
        INTEGER :: F2M_ID_SURRUONDING,F2M_ID_HORIZONTAL,F2M_ID_TOP,F2F_INDEX
        INTEGER(KIND = OMP_LOCK_KIND) :: LCK
        
        CALL OMP_INIT_LOCK(LCK)
                                                            !
        !$OMP PARALLEL SHARED(CONV_CV_SIZE, ACTIVE_SIZE_DUAL,ACTIVE_DOF, ACTIVE_DOF_DUAL, MATRIX_FLOW_VALS, MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, MATRIX_F2M_VALS, VECTOR_MATRIX, VECTOR_FRACTURE,ROW_START_F2M,MATRIX_ROW_STARTS,MATRIX_CONNECTIVITY,COLUMN_NUM_M2F)
        !$OMP DO SCHEDULE(STATIC) PRIVATE(AI,II, C_VECTOR_MATRIX,C_VECTOR_FRACTURE_SURRUONDING,C_VECTOR_FRACTURE_HORIZONTAL,C_VECTOR_FRACTURE_TOP, TEMP,TEMP_TOP_FRACTURE,C_F2F_FRACTURE_TOP_1,C_F2F_FRACTURE_TOP_2,C_F2F_FRACTURE_TOP_3,C_F2F_FRACTURE_HORIZONTAL_1,C_F2F_FRACTURE_HORIZONTAL_2,C_F2F_FRACTURE_HORIZONTAL_3,C_F2F_FRACTURE_SURRUONDING_1,C_F2F_FRACTURE_SURRUONDING_2,C_F2F_FRACTURE_SURRUONDING_3,C_M2F_FRACTURE_SURRUONDING,C_M2F_FRACTURE_HORIZONTAL,C_M2F_FRACTURE_TOP,C_M2M_MATRIX,C_F2M_FRACTURE_SURRUONDING,C_F2M_FRACTURE_HORIZONTAL,C_F2M_FRACTURE_TOP,ROW_NUMBER_SURRUONDING,ROW_NUMBER_HORIZONTAL,ROW_NUMBER_TOP,F2M_ID_SURRUONDING,F2M_ID_HORIZONTAL,F2M_ID_TOP,F2F_INDEX)
        DO AI = 0, CONV_CV_SIZE - 1
            
            ROW_NUMBER_SURRUONDING = ACTIVE_DOF_DUAL(AI)
            ROW_NUMBER_HORIZONTAL = ACTIVE_DOF_DUAL(AI+CONV_CV_SIZE)
            ROW_NUMBER_TOP = ACTIVE_DOF_DUAL(AI+2*CONV_CV_SIZE)
            
            F2M_ID_SURRUONDING = ROW_START_F2M(ROW_NUMBER_SURRUONDING)
            F2M_ID_HORIZONTAL = ROW_START_F2M(ROW_NUMBER_HORIZONTAL)
            F2M_ID_TOP=-1
            IF(ROW_NUMBER_TOP .NE. -1) THEN
                F2M_ID_TOP = ROW_START_F2M(ROW_NUMBER_TOP) +1
            ENDIF
            
            C_M2M_MATRIX = 9 * AI
            C_F2M_FRACTURE_SURRUONDING = 9* F2M_ID_SURRUONDING
            C_F2M_FRACTURE_HORIZONTAL = 9*F2M_ID_HORIZONTAL
            IF(ROW_NUMBER_TOP .NE. -1) THEN
                C_F2M_FRACTURE_TOP = 9*F2M_ID_TOP
            ENDIF
            C_M2F_FRACTURE_SURRUONDING = 9* (3*AI)
            C_M2F_FRACTURE_HORIZONTAL = 9*(3*AI+1)
            IF(ROW_NUMBER_TOP .NE. -1) THEN
                C_M2F_FRACTURE_TOP = 9*(3*AI+2)
            ENDIF
            
            !SURROUNDING
            F2F_INDEX=-1
            DO II=MATRIX_ROW_STARTS(ROW_NUMBER_SURRUONDING),MATRIX_ROW_STARTS(ROW_NUMBER_SURRUONDING+1)-1
                IF(MATRIX_CONNECTIVITY(II) .EQ. COLUMN_NUM_M2F(3*AI)) F2F_INDEX=II
            ENDDO
            C_F2F_FRACTURE_SURRUONDING_1 = 9 * F2F_INDEX
            F2F_INDEX=-1
            DO II=MATRIX_ROW_STARTS(ROW_NUMBER_SURRUONDING),MATRIX_ROW_STARTS(ROW_NUMBER_SURRUONDING+1)-1
                IF(MATRIX_CONNECTIVITY(II) .EQ. COLUMN_NUM_M2F(3*AI+1)) F2F_INDEX=II
            ENDDO
            C_F2F_FRACTURE_SURRUONDING_2 = 9 * F2F_INDEX
            IF(COLUMN_NUM_M2F(3*AI+2) .NE. -1) THEN
                F2F_INDEX=-1
                DO II=MATRIX_ROW_STARTS(ROW_NUMBER_SURRUONDING),MATRIX_ROW_STARTS(ROW_NUMBER_SURRUONDING+1)-1
                    IF(MATRIX_CONNECTIVITY(II) .EQ. COLUMN_NUM_M2F(3*AI+2)) F2F_INDEX=II
                ENDDO
                C_F2F_FRACTURE_SURRUONDING_3 = 9 * F2F_INDEX
            ELSE
                C_F2F_FRACTURE_SURRUONDING_3 =-1
            ENDIF
            
            !HORIZONTAL
            F2F_INDEX=-1
            DO II=MATRIX_ROW_STARTS(ROW_NUMBER_HORIZONTAL),MATRIX_ROW_STARTS(ROW_NUMBER_HORIZONTAL+1)-1
                IF(MATRIX_CONNECTIVITY(II) .EQ. COLUMN_NUM_M2F(3*AI)) F2F_INDEX=II
            ENDDO
            C_F2F_FRACTURE_HORIZONTAL_1 = 9 * F2F_INDEX
            F2F_INDEX=-1
            DO II=MATRIX_ROW_STARTS(ROW_NUMBER_HORIZONTAL),MATRIX_ROW_STARTS(ROW_NUMBER_HORIZONTAL+1)-1
                IF(MATRIX_CONNECTIVITY(II) .EQ. COLUMN_NUM_M2F(3*AI+1)) F2F_INDEX=II
            ENDDO
            C_F2F_FRACTURE_HORIZONTAL_2 = 9 * F2F_INDEX
            IF(COLUMN_NUM_M2F(3*AI+2) .NE. -1) THEN
                F2F_INDEX=-1
                DO II=MATRIX_ROW_STARTS(ROW_NUMBER_HORIZONTAL),MATRIX_ROW_STARTS(ROW_NUMBER_HORIZONTAL+1)-1
                    IF(MATRIX_CONNECTIVITY(II) .EQ. COLUMN_NUM_M2F(3*AI+2)) F2F_INDEX=II
                ENDDO
                C_F2F_FRACTURE_HORIZONTAL_3 = 9 * F2F_INDEX
            ELSE
                C_F2F_FRACTURE_HORIZONTAL_3 =-1
            ENDIF
            
            !TOP FRACTURE
            IF(ROW_NUMBER_TOP .NE. -1) THEN
                F2F_INDEX=-1
                DO II=MATRIX_ROW_STARTS(ROW_NUMBER_TOP),MATRIX_ROW_STARTS(ROW_NUMBER_TOP+1)-1
                    IF(MATRIX_CONNECTIVITY(II) .EQ. COLUMN_NUM_M2F(3*AI)) F2F_INDEX=II
                ENDDO
                C_F2F_FRACTURE_TOP_1 = 9 * F2F_INDEX
                F2F_INDEX=-1
                DO II=MATRIX_ROW_STARTS(ROW_NUMBER_TOP),MATRIX_ROW_STARTS(ROW_NUMBER_TOP+1)-1
                    IF(MATRIX_CONNECTIVITY(II) .EQ. COLUMN_NUM_M2F(3*AI+1)) F2F_INDEX=II
                ENDDO
                C_F2F_FRACTURE_TOP_2 = 9 * F2F_INDEX
                IF(COLUMN_NUM_M2F(3*AI+2) .NE. -1) THEN
                    F2F_INDEX=-1
                    DO II=MATRIX_ROW_STARTS(ROW_NUMBER_TOP),MATRIX_ROW_STARTS(ROW_NUMBER_TOP+1)-1
                        IF(MATRIX_CONNECTIVITY(II) .EQ. COLUMN_NUM_M2F(3*AI+2)) F2F_INDEX=II
                    ENDDO
                    C_F2F_FRACTURE_TOP_3 = 9 * F2F_INDEX
                ELSE
                    C_F2F_FRACTURE_TOP_3 =-1
                ENDIF
            ENDIF
            
            C_VECTOR_MATRIX = 3 * AI
            C_VECTOR_FRACTURE_SURRUONDING  = 3*ROW_NUMBER_SURRUONDING
            C_VECTOR_FRACTURE_HORIZONTAL  = 3*ROW_NUMBER_HORIZONTAL
            IF(ROW_NUMBER_TOP .NE. -1) THEN
                C_VECTOR_FRACTURE_TOP  = 3*ROW_NUMBER_TOP
            ENDIF
           
            CALL INV__(MATRIX_MATRIX_VALS(C_M2M_MATRIX:C_M2M_MATRIX + 8))
                
            TEMP = 0.D0          
            !SURROUNDING FRACTURE
            CALL MULT_MM__(MATRIX_F2M_VALS(C_F2M_FRACTURE_SURRUONDING :C_F2M_FRACTURE_SURRUONDING  + 8), MATRIX_MATRIX_VALS(C_M2M_MATRIX:C_M2M_MATRIX + 8), TEMP, 1.D0, 0, 0, 0)
            CALL MULT_MV__(TEMP, VECTOR_MATRIX(C_VECTOR_MATRIX:C_VECTOR_MATRIX + 2), VECTOR_FRACTURE(C_VECTOR_FRACTURE_SURRUONDING:C_VECTOR_FRACTURE_SURRUONDING + 2), -1.D0, 0, 0)
            CALL MULT_MM__(TEMP, MATRIX_M2F_VALS(C_M2F_FRACTURE_SURRUONDING:C_M2F_FRACTURE_SURRUONDING + 8), MATRIX_FLOW_VALS(C_F2F_FRACTURE_SURRUONDING_1:C_F2F_FRACTURE_SURRUONDING_1 + 8), -1.D0, 0, 0, 0)
            CALL MULT_MM__(TEMP, MATRIX_M2F_VALS(C_M2F_FRACTURE_HORIZONTAL:C_M2F_FRACTURE_HORIZONTAL + 8), MATRIX_FLOW_VALS(C_F2F_FRACTURE_SURRUONDING_2:C_F2F_FRACTURE_SURRUONDING_2 + 8), -1.D0, 0, 0, 0)
            IF(C_F2F_FRACTURE_SURRUONDING_3 .GT. 0) THEN
                CALL MULT_MM__(TEMP, MATRIX_M2F_VALS(C_M2F_FRACTURE_TOP:C_M2F_FRACTURE_TOP + 8), MATRIX_FLOW_VALS(C_F2F_FRACTURE_SURRUONDING_3:C_F2F_FRACTURE_SURRUONDING_3 + 8), -1.D0, 0, 0, 0)
            END IF
               
            TEMP = 0.D0
            !HORIZONTAL FRACTURE      
            CALL MULT_MM__(MATRIX_F2M_VALS(C_F2M_FRACTURE_HORIZONTAL :C_F2M_FRACTURE_HORIZONTAL  + 8), MATRIX_MATRIX_VALS(C_M2M_MATRIX:C_M2M_MATRIX + 8), TEMP, 1.D0, 0, 0, 0)
            CALL MULT_MV__(TEMP, VECTOR_MATRIX(C_VECTOR_MATRIX:C_VECTOR_MATRIX + 2), VECTOR_FRACTURE(C_VECTOR_FRACTURE_HORIZONTAL:C_VECTOR_FRACTURE_HORIZONTAL + 2), -1.D0, 0, 0)
            CALL MULT_MM__(TEMP, MATRIX_M2F_VALS(C_M2F_FRACTURE_SURRUONDING:C_M2F_FRACTURE_SURRUONDING + 8), MATRIX_FLOW_VALS(C_F2F_FRACTURE_HORIZONTAL_1:C_F2F_FRACTURE_HORIZONTAL_1 + 8), -1.D0, 0, 0, 0)
            CALL MULT_MM__(TEMP, MATRIX_M2F_VALS(C_M2F_FRACTURE_HORIZONTAL:C_M2F_FRACTURE_HORIZONTAL + 8), MATRIX_FLOW_VALS(C_F2F_FRACTURE_HORIZONTAL_2:C_F2F_FRACTURE_HORIZONTAL_2 + 8), -1.D0, 0, 0, 0)
            IF(C_F2F_FRACTURE_HORIZONTAL_3 .GT. 0) THEN
                CALL MULT_MM__(TEMP, MATRIX_M2F_VALS(C_M2F_FRACTURE_TOP:C_M2F_FRACTURE_TOP + 8), MATRIX_FLOW_VALS(C_F2F_FRACTURE_HORIZONTAL_3:C_F2F_FRACTURE_HORIZONTAL_3 + 8), -1.D0, 0, 0, 0)
            END IF 
            
            TEMP_TOP_FRACTURE = 0.D0
            !TOP FRACTURE
            IF(ROW_NUMBER_TOP .NE. -1) THEN
                CALL MULT_MM__(MATRIX_F2M_VALS(C_F2M_FRACTURE_TOP :C_F2M_FRACTURE_TOP  + 8), MATRIX_MATRIX_VALS(C_M2M_MATRIX:C_M2M_MATRIX + 8), TEMP_TOP_FRACTURE, 1.D0, 0, 0, 0)
                CALL MULT_MV__(TEMP_TOP_FRACTURE, VECTOR_MATRIX(C_VECTOR_MATRIX:C_VECTOR_MATRIX + 2), VECTOR_FRACTURE(C_VECTOR_FRACTURE_TOP:C_VECTOR_FRACTURE_TOP + 2), -1.D0, 0, 0)
                CALL OMP_SET_LOCK(LCK)
                    CALL MULT_MM__(TEMP_TOP_FRACTURE, MATRIX_M2F_VALS(C_M2F_FRACTURE_SURRUONDING:C_M2F_FRACTURE_SURRUONDING + 8), MATRIX_FLOW_VALS(C_F2F_FRACTURE_TOP_1:C_F2F_FRACTURE_TOP_1 + 8), -1.D0, 0, 0, 0)       
                    IF(C_F2F_FRACTURE_TOP_2 .GT. 0) THEN
                        CALL MULT_MM__(TEMP_TOP_FRACTURE, MATRIX_M2F_VALS(C_M2F_FRACTURE_HORIZONTAL:C_M2F_FRACTURE_HORIZONTAL + 8), MATRIX_FLOW_VALS(C_F2F_FRACTURE_TOP_2:C_F2F_FRACTURE_TOP_2 + 8), -1.D0, 0, 0, 0)
                    END IF
                    CALL MULT_MM__(TEMP_TOP_FRACTURE, MATRIX_M2F_VALS(C_M2F_FRACTURE_TOP:C_M2F_FRACTURE_TOP + 8), MATRIX_FLOW_VALS(C_F2F_FRACTURE_TOP_3:C_F2F_FRACTURE_TOP_3 + 8), -1.D0, 0, 0, 0)
                CALL OMP_UNSET_LOCK(LCK)
            ENDIF
            
            
        END DO
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL
        CALL OMP_DESTROY_LOCK(LCK)
    END SUBROUTINE
                                                                                                 !                  
    SUBROUTINE CONDENSE_MATRIX_PRESSURE_ON_FRACTURE_PRESSURE__(CONV_CV_SIZE, ACTIVE_SIZE_DUAL, DOF_SIZE, ACTIVE_DOF_DUAL, MATRIX_FLOW_VALS, DIAG_DOF, PRESSURE_M2M_VALS, PRESSURE_M2F_VALS, PRESSURE_F2M_VALS, PRESSURE_VECTOR_MATRIX, PRESSURE_VECTOR_FRACTURE)
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'CONDENSE_MATRIX_PRESSURE_ON_FRACTURE_PRESSURE__':: RETINA_SOLVER
        USE OMP_LIB    
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, ACTIVE_SIZE_DUAL, DOF_SIZE
        INTEGER, DIMENSION(0:ACTIVE_SIZE_DUAL - 1), INTENT(IN) :: ACTIVE_DOF_DUAL
        INTEGER, DIMENSION(0:CONV_CV_SIZE - 1), INTENT(IN) :: DIAG_DOF
        DOUBLE PRECISION, DIMENSION(0:DOF_SIZE - 1), INTENT(INOUT) :: MATRIX_FLOW_VALS
        DOUBLE PRECISION, DIMENSION(0:CONV_CV_SIZE - 1), INTENT(INOUT) :: PRESSURE_M2M_VALS
        DOUBLE PRECISION, DIMENSION(0:CONV_CV_SIZE - 1), INTENT(IN) :: PRESSURE_M2F_VALS, PRESSURE_F2M_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(INOUT) :: PRESSURE_VECTOR_FRACTURE
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(IN) :: PRESSURE_VECTOR_MATRIX
    
        INTEGER :: AI, I, II, C0_MATRIX, C1_MATRIX, C_VECTOR
        DOUBLE PRECISION :: TEMP
                                                            !
        !$OMP PARALLEL SHARED(CONV_CV_SIZE, ACTIVE_SIZE_DUAL, ACTIVE_DOF_DUAL, MATRIX_FLOW_VALS, DIAG_DOF, PRESSURE_M2M_VALS, PRESSURE_M2F_VALS, PRESSURE_F2M_VALS, PRESSURE_VECTOR_MATRIX, PRESSURE_VECTOR_FRACTURE)
        !$OMP DO SCHEDULE(STATIC) PRIVATE(AI, I, C0_MATRIX, C_VECTOR, II, C1_MATRIX, TEMP)
        DO AI = 0, ACTIVE_SIZE_DUAL - 1
            I = ACTIVE_DOF_DUAL(AI)
            C0_MATRIX = I
            C1_MATRIX = DIAG_DOF(I)
            C_VECTOR = 3 * I
            PRESSURE_M2M_VALS(C0_MATRIX) = 1.D0 / PRESSURE_M2M_VALS(C0_MATRIX)
            TEMP = 0.D0
            TEMP = PRESSURE_F2M_VALS(C0_MATRIX) * PRESSURE_M2M_VALS(C0_MATRIX)
            PRESSURE_VECTOR_FRACTURE(C_VECTOR + 2) = PRESSURE_VECTOR_FRACTURE(C_VECTOR + 2) - TEMP * PRESSURE_VECTOR_MATRIX(C_VECTOR + 2)
            MATRIX_FLOW_VALS(C1_MATRIX) = MATRIX_FLOW_VALS(C1_MATRIX) - TEMP * PRESSURE_M2F_VALS(C0_MATRIX)
        END DO
        !$OMP END DO NOWAIT
        !$OMP END PARALLEL
    END SUBROUTINE
                                                                          !
    SUBROUTINE AIM_EVALUATE_MATRIX_RESULT__(CONV_CV_SIZE, ACTIVE_SIZE_DUAL, ACTIVE_DOF_DUAL  , MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, VECTOR_MATRIX, RESULT_MATRIX, RESULT_FRACTURE, IMPLICITNESS, NATURAL_ID)
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'AIM_EVALUATE_MATRIX_RESULT__':: RETINA_SOLVER
        USE OMP_LIB    
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, ACTIVE_SIZE_DUAL
        INTEGER, DIMENSION(0: ACTIVE_SIZE_DUAL - 1), INTENT(IN) :: ACTIVE_DOF_DUAL
        INTEGER, DIMENSION(0: 2*CONV_CV_SIZE  - 1), INTENT(IN) :: IMPLICITNESS, NATURAL_ID
        DOUBLE PRECISION, DIMENSION(0:9 * CONV_CV_SIZE - 1), INTENT(IN) :: MATRIX_MATRIX_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * CONV_CV_SIZE - 1), INTENT(IN) :: MATRIX_M2F_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(IN) :: RESULT_FRACTURE
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(INOUT) :: RESULT_MATRIX, VECTOR_MATRIX
    
        INTEGER :: AI, I, II, C_MATRIX, C_VECTOR, MIN_F, MIN_M
                                                            !
        !$OMP PARALLEL SHARED(CONV_CV_SIZE, ACTIVE_SIZE_DUAL, ACTIVE_DOF_DUAL, MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, VECTOR_MATRIX, RESULT_MATRIX, RESULT_FRACTURE)
        !$OMP DO SCHEDULE(STATIC) PRIVATE(AI, I, MIN_F, MIN_M, C_MATRIX, C_VECTOR, II)
        DO AI = 0, ACTIVE_SIZE_DUAL - 1
            I = ACTIVE_DOF_DUAL(AI)
            IF(IMPLICITNESS(NATURAL_ID(I)) .EQ. 1) THEN
                MIN_F = 0
            ELSE
                MIN_F = 2
            END IF
            IF(IMPLICITNESS(NATURAL_ID(I+CONV_CV_SIZE)) .EQ. 1) THEN
                MIN_M= 0 
            ELSE
                MIN_M= 2
            END IF
            C_MATRIX = 9 * I
            C_VECTOR = 3 * I
            CALL MULT_MV__(MATRIX_M2F_VALS(C_MATRIX:C_MATRIX + 8), RESULT_FRACTURE(C_VECTOR:C_VECTOR + 2), VECTOR_MATRIX(C_VECTOR:C_VECTOR + 2), -1.D0, MIN_M, MIN_F)            
            !DEC$ SIMD
            DO II = 0, MIN_M
                RESULT_MATRIX(C_VECTOR + II) = 0.D0
            END DO
            !DEC$ SIMD
            DO II = MIN_M, 2
                RESULT_MATRIX(C_VECTOR + II) = 0.D0
            END DO
            CALL MULT_MV__(MATRIX_MATRIX_VALS(C_MATRIX:C_MATRIX + 8), VECTOR_MATRIX(C_VECTOR:C_VECTOR + 2), RESULT_MATRIX(C_VECTOR:C_VECTOR + 2), 1.D0, MIN_M, MIN_M)
        END DO
        !$OMP END DO
        !$OMP END PARALLEL
    END SUBROUTINE
    
                                                                      !         
    SUBROUTINE EVALUATE_MATRIX_RESULT__(CONV_CV_SIZE, ACTIVE_SIZE_DUAL, ACTIVE_DOF_DUAL , MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, VECTOR_MATRIX, RESULT_MATRIX, RESULT_FRACTURE)
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'EVALUATE_MATRIX_RESULT__':: RETINA_SOLVER
        USE OMP_LIB    
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, ACTIVE_SIZE_DUAL
        INTEGER, DIMENSION(0:ACTIVE_SIZE_DUAL - 1), INTENT(IN) :: ACTIVE_DOF_DUAL
        DOUBLE PRECISION, DIMENSION(0:9 * CONV_CV_SIZE - 1), INTENT(IN) :: MATRIX_MATRIX_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * CONV_CV_SIZE - 1), INTENT(IN) :: MATRIX_M2F_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(IN) :: RESULT_FRACTURE
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(INOUT) :: RESULT_MATRIX, VECTOR_MATRIX
    
        INTEGER :: AI, I, II, C_MATRIX, C_VECTOR
                                                            !  
        !$OMP PARALLEL SHARED(CONV_CV_SIZE, ACTIVE_SIZE_DUAL, ACTIVE_DOF_DUAL, MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, VECTOR_MATRIX, RESULT_MATRIX, RESULT_FRACTURE)
        !$OMP DO SCHEDULE(STATIC) PRIVATE(AI, I, C_MATRIX, C_VECTOR, II)
        DO AI = 0, ACTIVE_SIZE_DUAL - 1
            I = ACTIVE_DOF_DUAL(AI)
            C_MATRIX = 9 * I
            C_VECTOR = 3 * I
            CALL MULT_MV__(MATRIX_M2F_VALS(C_MATRIX:C_MATRIX + 8), RESULT_FRACTURE(C_VECTOR:C_VECTOR + 2), VECTOR_MATRIX(C_VECTOR:C_VECTOR + 2), -1.D0, 0, 0)            
            !DEC$ SIMD
            DO II = 0, 2
                RESULT_MATRIX(C_VECTOR + II) = 0.D0
            END DO
            CALL MULT_MV__(MATRIX_MATRIX_VALS(C_MATRIX:C_MATRIX + 8), VECTOR_MATRIX(C_VECTOR:C_VECTOR + 2), RESULT_MATRIX(C_VECTOR:C_VECTOR + 2), 1.D0, 0, 0)
        END DO
        !$OMP END DO
        !$OMP END PARALLEL
    END SUBROUTINE
    
    SUBROUTINE EVALUATE_MATRIX_RESULT_BLOCK_TO_BLOCK__(CONV_CV_SIZE, ACTIVE_SIZE_DUAL,ACTIVE_DOF, ACTIVE_DOF_DUAL , MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, VECTOR_MATRIX, RESULT_MATRIX, RESULT_FRACTURE,F2M_SIZE)
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'EVALUATE_MATRIX_RESULT_BLOCK_TO_BLOCK__':: RETINA_SOLVER
        USE OMP_LIB    
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, ACTIVE_SIZE_DUAL,ACTIVE_DOF,F2M_SIZE
        INTEGER, DIMENSION(0:ACTIVE_SIZE_DUAL - 1), INTENT(IN) :: ACTIVE_DOF_DUAL
        DOUBLE PRECISION, DIMENSION(0:9 * CONV_CV_SIZE - 1), INTENT(IN) :: MATRIX_MATRIX_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * F2M_SIZE - 1), INTENT(IN) :: MATRIX_M2F_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * ACTIVE_DOF - 1), INTENT(IN) :: RESULT_FRACTURE
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(INOUT) :: RESULT_MATRIX, VECTOR_MATRIX
        INTEGER :: AI, II
        INTEGER :: C_MATRIX,C_M2F_FRACTURE_SURRUONDING,C_M2F_FRACTURE_HORIZONTAL,C_M2F_FRACTURE_TOP
        INTEGER :: C_VECTOR,C_VECTOR_FRACTURE_SURRUONDING,C_VECTOR_FRACTURE_HORIZONTAL,C_VECTOR_FRACTURE_TOP
        INTEGER :: ROW_NUMBER_SURRUONDING,ROW_NUMBER_HORIZONTAL,ROW_NUMBER_TOP
        INTEGER :: F2M_ID_SURRUONDING,F2M_ID_HORIZONTAL,F2M_ID_TOP
                                                            !  
        !$OMP PARALLEL SHARED(CONV_CV_SIZE, ACTIVE_SIZE_DUAL,ACTIVE_DOF, ACTIVE_DOF_DUAL, MATRIX_MATRIX_VALS, MATRIX_M2F_VALS, VECTOR_MATRIX, RESULT_MATRIX, RESULT_FRACTURE)
        !$OMP DO SCHEDULE(STATIC) PRIVATE(AI, II, C_MATRIX,C_M2F_FRACTURE_SURRUONDING,C_M2F_FRACTURE_HORIZONTAL,C_M2F_FRACTURE_TOP,C_VECTOR,C_VECTOR_FRACTURE_SURRUONDING,C_VECTOR_FRACTURE_HORIZONTAL,C_VECTOR_FRACTURE_TOP,ROW_NUMBER_SURRUONDING,ROW_NUMBER_HORIZONTAL,ROW_NUMBER_TOP,F2M_ID_SURRUONDING,F2M_ID_HORIZONTAL,F2M_ID_TOP)
        DO AI = 0, CONV_CV_SIZE - 1
            
            ROW_NUMBER_SURRUONDING = ACTIVE_DOF_DUAL(AI)
            ROW_NUMBER_HORIZONTAL = ACTIVE_DOF_DUAL(AI+CONV_CV_SIZE)
            ROW_NUMBER_TOP = ACTIVE_DOF_DUAL(AI+2*CONV_CV_SIZE)
                      
            C_MATRIX = 9 * AI
            C_M2F_FRACTURE_SURRUONDING = 9* (AI*3)
            C_M2F_FRACTURE_HORIZONTAL = 9* (AI*3+1)
            IF(ROW_NUMBER_TOP .NE. -1) THEN
                C_M2F_FRACTURE_TOP = 9* (AI*3+2)
            ENDIF
            
            C_VECTOR = 3 * AI
            C_VECTOR_FRACTURE_SURRUONDING  = 3*ROW_NUMBER_SURRUONDING
            C_VECTOR_FRACTURE_HORIZONTAL  = 3*ROW_NUMBER_HORIZONTAL
            IF(ROW_NUMBER_TOP .NE. -1) THEN
                C_VECTOR_FRACTURE_TOP  = 3*ROW_NUMBER_TOP
            ENDIF
            
            !SURROUNDING FRACTURE
            CALL MULT_MV__(MATRIX_M2F_VALS(C_M2F_FRACTURE_SURRUONDING:C_M2F_FRACTURE_SURRUONDING + 8), RESULT_FRACTURE(C_VECTOR_FRACTURE_SURRUONDING:C_VECTOR_FRACTURE_SURRUONDING + 2), VECTOR_MATRIX(C_VECTOR:C_VECTOR + 2), -1.D0, 0, 0)            
            !HORIZONTAL FRACTURE
            CALL MULT_MV__(MATRIX_M2F_VALS(C_M2F_FRACTURE_HORIZONTAL:C_M2F_FRACTURE_HORIZONTAL + 8), RESULT_FRACTURE(C_VECTOR_FRACTURE_HORIZONTAL:C_VECTOR_FRACTURE_HORIZONTAL + 2), VECTOR_MATRIX(C_VECTOR:C_VECTOR + 2), -1.D0, 0, 0)            
            !BASE FRACTURE
            IF(ROW_NUMBER_TOP .NE. -1) THEN
                CALL MULT_MV__(MATRIX_M2F_VALS(C_M2F_FRACTURE_TOP:C_M2F_FRACTURE_TOP + 8), RESULT_FRACTURE(C_VECTOR_FRACTURE_TOP:C_VECTOR_FRACTURE_TOP + 2), VECTOR_MATRIX(C_VECTOR:C_VECTOR + 2), -1.D0, 0, 0)            
            ENDIF
            
            !DEC$ SIMD
            DO II = 0, 2
                RESULT_MATRIX(C_VECTOR + II) = 0.D0
            END DO
            CALL MULT_MV__(MATRIX_MATRIX_VALS(C_MATRIX:C_MATRIX + 8), VECTOR_MATRIX(C_VECTOR:C_VECTOR + 2), RESULT_MATRIX(C_VECTOR:C_VECTOR + 2), 1.D0, 0, 0)
        END DO
        !$OMP END DO
        !$OMP END PARALLEL
    END SUBROUTINE
    
    SUBROUTINE EVALUATE_WELL_RESULT__(CONV_CV_SIZE, W_SIZE, CON_SIZE, MATRIX_W2C_VALS, MATRIX_W_VALS, VECTOR_W_VALS, RESULT_FLOW_VALS, RESULT_W_VALS, WELL_DOF_CONNECTIVITY, WELL_DOF_ROW_STARTS)
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'EVALUATE_WELL_RESULT__':: RETINA_SOLVER
        USE OMP_LIB    
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, W_SIZE, CON_SIZE
        DOUBLE PRECISION, DIMENSION(0:9 * CON_SIZE - 1), INTENT(IN) :: MATRIX_W2C_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * W_SIZE - 1), INTENT(IN) :: MATRIX_W_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * W_SIZE - 1), INTENT(INOUT) :: VECTOR_W_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * W_SIZE - 1), INTENT(OUT) :: RESULT_W_VALS
        DOUBLE PRECISION, DIMENSION(0:3 * CONV_CV_SIZE - 1), INTENT(IN) :: RESULT_FLOW_VALS
        INTEGER, DIMENSION(0:CON_SIZE - 1), INTENT(IN) :: WELL_DOF_CONNECTIVITY
        INTEGER, DIMENSION(0:W_SIZE), INTENT(IN) :: WELL_DOF_ROW_STARTS
    
        INTEGER :: I, J_INDEX, J

        !$OMP PARALLEL SHARED(VECTOR_W_VALS, RESULT_W_VALS)
        !$OMP DO SCHEDULE(STATIC) PRIVATE(I, J_INDEX, J)
        DO I = 0, W_SIZE - 1
            DO J_INDEX = WELL_DOF_ROW_STARTS(I), WELL_DOF_ROW_STARTS(I + 1) - 1
                J = WELL_DOF_CONNECTIVITY(J_INDEX)
                CALL MULT_MV__(MATRIX_W2C_VALS(9 * J_INDEX:9 * J_INDEX + 8), RESULT_FLOW_VALS(3 * J:3 * J + 2), VECTOR_W_VALS(3 * I:3 * I + 2), -1.D0, 0, 0)
            END DO
            CALL COPY_MULT_MV__(MATRIX_W_VALS(9 * I:9 * I + 8), VECTOR_W_VALS(3 * I:3 * I + 2), RESULT_W_VALS(3 * I:3 * I + 2), 1.D0)
        END DO
        !$OMP END DO
        !$OMP END PARALLEL
        
    END SUBROUTINE
    
    SUBROUTINE PERFORM_QUASI_IMPES_TRANSFORMATION__(CONV_CV_SIZE, ACTIVE_SIZE, W_SIZE, CON_SIZE, DOF_SIZE, ACTIVE_DOF, VEC_CV, VEC_WELL, MATRIX_FLOW_VALS, MATRIX_C2W_VALS, MATRIX_W2C_VALS, MATRIX_W_VALS, MATRIX_CONNECTIVITY, MATRIX_ROW_STARTS, DOF_WELL_CONNECTIVITY, DOF_WELL_ROW_STARTS, WELL_DOF_CONNECTIVITY, WELL_DOF_ROW_STARTS, DIAG_INDICES, IS_PBH_SOLVE)        
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'PERFORM_QUASI_IMPES_TRANSFORMATION__':: RETINA_SOLVER
        USE OMP_LIB    
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, ACTIVE_SIZE, W_SIZE, CON_SIZE, DOF_SIZE
        INTEGER, DIMENSION(0:ACTIVE_SIZE - 1), INTENT(IN) :: ACTIVE_DOF
        DOUBLE PRECISION, DIMENSION(0:CONV_CV_SIZE * 3 - 1), INTENT(INOUT) :: VEC_CV
        DOUBLE PRECISION, DIMENSION(0:W_SIZE * 3 - 1), INTENT(INOUT) :: VEC_WELL
        DOUBLE PRECISION, DIMENSION(0:9 * DOF_SIZE - 1), INTENT(INOUT) :: MATRIX_FLOW_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * CON_sIZE - 1), INTENT(INOUT) :: MATRIX_C2W_VALS, MATRIX_W2C_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * W_SIZE - 1), INTENT(INOUT) :: MATRIX_W_VALS
        INTEGER, DIMENSION(0:DOF_SIZE - 1), INTENT(IN) :: MATRIX_CONNECTIVITY
        INTEGER, DIMENSION(0:CONV_CV_SIZE), INTENT(IN) :: MATRIX_ROW_STARTS
        INTEGER, DIMENSION(0:CON_SIZE - 1), INTENT(IN) :: DOF_WELL_CONNECTIVITY, WELL_DOF_CONNECTIVITY
        INTEGER, DIMENSION(0:CONV_CV_SIZE), INTENT(IN) :: DOF_WELL_ROW_STARTS
        INTEGER, DIMENSION(0:W_SIZE), INTENT(IN) :: WELL_DOF_ROW_STARTS
        INTEGER, DIMENSION(0:CONV_CV_SIZE - 1), INTENT(IN) :: DIAG_INDICES
        LOGICAL, DIMENSION(0:W_SIZE-1), INTENT(IN) :: IS_PBH_SOLVE
    
        DOUBLE PRECISION, DIMENSION(0:8) :: DIAG
        DOUBLE PRECISION, DIMENSION(0:8) :: DIAG_INV
        DOUBLE PRECISION, DIMENSION(0:1) :: TERM
        INTEGER :: AI, I, INDEX, II, JJ, KK, C0
        DOUBLE PRECISION :: MULT
    
        !$OMP PARALLEL
            !$OMP DO SCHEDULE(STATIC) PRIVATE(AI, I, C0, DIAG, II, JJ, DIAG_INV, TERM, KK, MULT, INDEX)
        DO AI = 0, ACTIVE_SIZE - 1
            I = ACTIVE_DOF(AI)
            C0 = 9 * DIAG_INDICES(I)
            DIAG = MATRIX_FLOW_VALS(C0:C0 + 8)                
            DIAG_INV = 0.D0
            DIAG_INV(8) = 1.D0
            DO II = 0, 1
                DO JJ = 0, 1
                    DIAG_INV(3 * II + JJ) = DIAG(3 * II + JJ)
                END DO
            END DO
            CALL INV__(DIAG_INV)
            ! TERM = DA(3,1:2) * INV(DA(1:2,1:2))
            DO JJ = 0, 1
                TERM(JJ) = 0.D0
                DO KK = 0, 1
                    TERM(JJ) = TERM(JJ) + DIAG(6 + KK) * DIAG_INV(3 * KK + JJ)
                END DO
            END DO
            ! A(3*I,:) = A(3*I,:) - TERM * A(3*I-2:3*I-2,:)
            IF ((DIAG(8) - TERM(0) * DIAG(2) - TERM(1) * DIAG(5)) .LT. 0.D0) THEN
                MULT = -1.D0
            ELSE
                MULT = 1.D0
            END IF
            
            DO INDEX = MATRIX_ROW_STARTS(I), MATRIX_ROW_STARTS(I + 1) - 1
                C0 = 9 * INDEX
                DO JJ = 0, 2
                    DO KK = 0, 1
                        MATRIX_FLOW_VALS(C0 + 6 + JJ) = MATRIX_FLOW_VALS(C0 + 6 + JJ) - TERM(KK) * MATRIX_FLOW_VALS(C0 + 3 * KK + JJ)
                    END DO
                    MATRIX_FLOW_VALS(C0 + 6 + JJ) = MATRIX_FLOW_VALS(C0 + 6 + JJ) * MULT
                END DO
            END DO
            DO INDEX = DOF_WELL_ROW_STARTS(I), DOF_WELL_ROW_STARTS(I + 1) - 1
                C0 = 9 * INDEX
                DO JJ = 0, 2
                    DO KK = 0, 1
                        MATRIX_C2W_VALS(C0 + 6 + JJ) = MATRIX_C2W_VALS(C0 + 6 + JJ) - TERM(KK) * MATRIX_C2W_VALS(C0 + 3 * KK + JJ)
                    END DO
                    MATRIX_C2W_VALS(C0 + 6 + JJ) = MATRIX_C2W_VALS(C0 + 6 + JJ) * MULT
                END DO
            END DO
            C0 = 3 * I
            DO KK = 0, 1
                VEC_CV(C0 + 2) = VEC_CV(C0 + 2) - TERM(KK) * VEC_CV(C0 + KK)
            END DO
            VEC_CV(C0 + 2) = VEC_CV(C0 + 2) * MULT
        END DO
            !$OMP END DO
        !$OMP END PARALLEL

        !$OMP PARALLEL
            !$OMP DO SCHEDULE(STATIC) PRIVATE(I, C0, DIAG, II, JJ, DIAG_INV, TERM, KK, MULT, INDEX)
        DO I = 0, W_SIZE - 1            
            !IF (IS_PBH_SOLVE(I)) THEN
                C0 = 9 * I
                DIAG = MATRIX_W_VALS(C0:C0 + 8)   
                DIAG_INV = 0.D0
                DIAG_INV(8) = 1.D0
                DO II = 0, 1
                    DO JJ = 0, 1
                        DIAG_INV(3 * II + JJ) = DIAG(3 * II + JJ)
                    END DO
                END DO
                CALL INV__(DIAG_INV)
                ! TERM = DA(3,1:2) * INV(DA(1:2,1:2))
                DO JJ = 0, 1
                    TERM(JJ) = 0.D0
                    DO KK = 0, 1
                        TERM(JJ) = TERM(JJ) + DIAG(6 + KK) * DIAG_INV(3 * KK + JJ)
                    END DO
                END DO
                IF ((DIAG(8) - TERM(0) * DIAG(2) - TERM(1) * DIAG(5)) .LT. 0.D0) THEN
                    MULT = -1.D0
                ELSE
                    MULT = 1.D0
                END IF
                DO JJ = 0, 2
                    DO KK = 0, 1
                        MATRIX_W_VALS(C0 + 6 + JJ) = MATRIX_W_VALS(C0 + 6 + JJ) - TERM(KK) * MATRIX_W_VALS(C0 + 3 * KK + JJ)
                    END DO
                    MATRIX_W_VALS(C0 + 6 + JJ) = MATRIX_W_VALS(C0 + 6 + JJ) * MULT
                END DO
                DO INDEX = WELL_DOF_ROW_STARTS(I), WELL_DOF_ROW_STARTS(I + 1) - 1
                    C0 = 9 * INDEX
                    DO JJ = 0, 2
                        DO KK = 0, 1
                            MATRIX_W2C_VALS(C0 + 6 + JJ) = MATRIX_W2C_VALS(C0 + 6 + JJ) - TERM(KK) * MATRIX_W2C_VALS(C0 + 3 * KK + JJ)
                        END DO
                        MATRIX_W2C_VALS(C0 + 6 + JJ) = MATRIX_W2C_VALS(C0 + 6 + JJ) * MULT
                    END DO
                END DO
                C0 = 3 * I
                DO KK = 0, 1
                    VEC_WELL(C0 + 2) = VEC_WELL(C0 + 2) - TERM(KK) * VEC_WELL(C0 + KK)
                END DO
                VEC_WELL(C0 + 2) = VEC_WELL(C0 + 2) * MULT
            !END IF
        END DO
            !$OMP END DO
        !$OMP END PARALLEL
                
    END SUBROUTINE

    SUBROUTINE PERFORM_MIN_SQUARE_QUASI_IMPES_TRANSFORMATION__(CONV_CV_SIZE, ACTIVE_SIZE, W_SIZE, CON_SIZE, DOF_SIZE, ACTIVE_DOF, VEC_CV, VEC_WELL, MATRIX_FLOW_VALS, MATRIX_C2W_VALS, MATRIX_W2C_VALS, MATRIX_W_VALS, MATRIX_CONNECTIVITY, MATRIX_ROW_STARTS, DOF_WELL_CONNECTIVITY, DOF_WELL_ROW_STARTS, WELL_DOF_CONNECTIVITY, WELL_DOF_ROW_STARTS, DIAG_INDICES, IS_PBH_SOLVE)        
        !DEC$ ATTRIBUTES DLLEXPORT, ALIAS : 'PERFORM_MIN_SQUARE_QUASI_IMPES_TRANSFORMATION__':: RETINA_SOLVER
        USE OMP_LIB    
        INTEGER, INTENT(IN) :: CONV_CV_SIZE, ACTIVE_SIZE, W_SIZE, CON_SIZE, DOF_SIZE
        INTEGER, DIMENSION(0:ACTIVE_SIZE - 1), INTENT(IN) :: ACTIVE_DOF
        DOUBLE PRECISION, DIMENSION(0:CONV_CV_SIZE * 3 - 1), INTENT(INOUT) :: VEC_CV
        DOUBLE PRECISION, DIMENSION(0:W_SIZE * 3 - 1), INTENT(INOUT) :: VEC_WELL
        DOUBLE PRECISION, DIMENSION(0:9 * DOF_SIZE - 1), INTENT(INOUT) :: MATRIX_FLOW_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * CON_sIZE - 1), INTENT(INOUT) :: MATRIX_C2W_VALS, MATRIX_W2C_VALS
        DOUBLE PRECISION, DIMENSION(0:9 * W_SIZE - 1), INTENT(INOUT) :: MATRIX_W_VALS
        INTEGER, DIMENSION(0:DOF_SIZE - 1), INTENT(IN) :: MATRIX_CONNECTIVITY
        INTEGER, DIMENSION(0:CONV_CV_SIZE), INTENT(IN) :: MATRIX_ROW_STARTS
        INTEGER, DIMENSION(0:CON_SIZE - 1), INTENT(IN) :: DOF_WELL_CONNECTIVITY, WELL_DOF_CONNECTIVITY
        INTEGER, DIMENSION(0:CONV_CV_SIZE), INTENT(IN) :: DOF_WELL_ROW_STARTS
        INTEGER, DIMENSION(0:W_SIZE), INTENT(IN) :: WELL_DOF_ROW_STARTS
        INTEGER, DIMENSION(0:CONV_CV_SIZE - 1), INTENT(IN) :: DIAG_INDICES
        LOGICAL, DIMENSION(0:W_SIZE-1), INTENT(IN) :: IS_PBH_SOLVE
        DOUBLE PRECISION, DIMENSION(0:8) :: DIAG, FV
        DOUBLE PRECISION, DIMENSION(0:1) :: TERM
        INTEGER :: AI, I, INDEX, JJ, KK, C0
        DOUBLE PRECISION, DIMENSION(0:2) :: A1, A2, A3
        DOUBLE PRECISION :: MULT, A11, A12, A21, A22, B1, B2, NOM_DET, DENOM_DET
    
        !$OMP PARALLEL
            !$OMP DO SCHEDULE(STATIC) PRIVATE(AI, I, C0, DIAG, A11, A12, A22, B1, B2, INDEX, FV, A1, A2, A3, A21, DENOM_DET, NOM_DET, TERM, MULT, JJ, KK)
        DO AI = 0, ACTIVE_SIZE - 1
            I = ACTIVE_DOF(AI)
            C0 = 9 * DIAG_INDICES(I)
            DIAG = MATRIX_FLOW_VALS(C0:C0 + 8)                
            A11 = 0.D0
            A12 = 0.D0
            A21 = 0.D0
            A22 = 0.D0
            B1 = 0.D0
            B2 = 0.D0
            DO INDEX = MATRIX_ROW_STARTS(I), MATRIX_ROW_STARTS(I + 1) - 1
                C0 = 9 * INDEX
                FV = MATRIX_FLOW_VALS(C0:C0 + 8)
                A1 = FV(0:2)
                A2 = FV(3:5)
                A3 = FV(6:8)
                A11 = A11 + A1(0) * A1(0) + A1(1) * A1(1)
                A12 = A12 + A1(0) * A2(0) + A1(1) * A2(1)                
                A22 = A22 + A2(0) * A2(0) + A2(1) * A2(1)
                B1 = B1 - A1(0) * A3(0) - A1(1) * A3(1)
                B2 = B2 - A2(0) * A3(0) - A2(1) * A3(1)
            END DO
            DO INDEX = DOF_WELL_ROW_STARTS(I), DOF_WELL_ROW_STARTS(I + 1) - 1
                C0 = 9 * INDEX
                FV = MATRIX_C2W_VALS(C0:C0 + 8)
                A1 = FV(0:2)
                A2 = FV(3:5)
                A3 = FV(6:8)
                A11 = A11 + A1(0) * A1(0) + A1(1) * A1(1)
                A12 = A12 + A1(0) * A2(0) + A1(1) * A2(1)                
                A22 = A22 + A2(0) * A2(0) + A2(1) * A2(1)
                B1 = B1 - A1(0) * A3(0) - A1(1) * A3(1)
                B2 = B2 - A2(0) * A3(0) - A2(1) * A3(1)
            END DO
            A21 = A12
            DENOM_DET = A11 * A22 - A12 * A21
            NOM_DET = B1 * A22 - A12 * B2
            TERM(0) = NOM_DET / DENOM_DET
            NOM_DET = A11 * B2 - B1 * A21
            TERM(1) = NOM_DET / DENOM_DET
            ! A(3*I,:) = A(3*I,:) - TERM * A(3*I-2:3*I-2,:)
            IF ((DIAG(8) + TERM(0) * DIAG(2) + TERM(1) * DIAG(5)) .LT. 0.D0) THEN
                MULT = -1.D0
            ELSE
                MULT = 1.D0
            END IF
            
            DO INDEX = MATRIX_ROW_STARTS(I), MATRIX_ROW_STARTS(I + 1) - 1
                C0 = 9 * INDEX
                DO JJ = 0, 2
                    DO KK = 0, 1
                        MATRIX_FLOW_VALS(C0 + 6 + JJ) = MATRIX_FLOW_VALS(C0 + 6 + JJ) + TERM(KK) * MATRIX_FLOW_VALS(C0 + 3 * KK + JJ)
                    END DO
                    MATRIX_FLOW_VALS(C0 + 6 + JJ) = MATRIX_FLOW_VALS(C0 + 6 + JJ) * MULT
                END DO
            END DO
            DO INDEX = DOF_WELL_ROW_STARTS(I), DOF_WELL_ROW_STARTS(I + 1) - 1
                C0 = 9 * INDEX
                DO JJ = 0, 2
                    DO KK = 0, 1
                        MATRIX_C2W_VALS(C0 + 6 + JJ) = MATRIX_C2W_VALS(C0 + 6 + JJ) + TERM(KK) * MATRIX_C2W_VALS(C0 + 3 * KK + JJ)
                    END DO
                    MATRIX_C2W_VALS(C0 + 6 + JJ) = MATRIX_C2W_VALS(C0 + 6 + JJ) * MULT
                END DO
            END DO
            C0 = 3 * I
            DO KK = 0, 1
                VEC_CV(C0 + 2) = VEC_CV(C0 + 2) + TERM(KK) * VEC_CV(C0 + KK)
            END DO
            VEC_CV(C0 + 2) = VEC_CV(C0 + 2) * MULT
        END DO
            !$OMP END DO
        !$OMP END PARALLEL

        !$OMP PARALLEL
            !$OMP DO SCHEDULE(STATIC) PRIVATE(I, C0, DIAG, FV, A1, A2, A3, A11, A12, A22, B1, B2, INDEX, A21, DENOM_DET, NOM_DET, TERM, MULT, JJ, KK)
        DO I = 0, W_SIZE - 1            
            !IF (IS_PBH_SOLVE(I)) THEN
                C0 = 9 * I
                DIAG = MATRIX_W_VALS(C0:C0 + 8)   
                
                FV = DIAG
                A1 = FV(0:2)
                A2 = FV(3:5)
                A3 = FV(6:8)
                A11 = A1(0) * A1(0) + A1(1) * A1(1)
                A12 = A1(0) * A2(0) + A1(1) * A2(1)                
                A22 = A2(0) * A2(0) + A2(1) * A2(1)
                B1 = - A1(0) * A3(0) - A1(1) * A3(1)
                B2 = - A2(0) * A3(0) - A2(1) * A3(1)
                DO INDEX = WELL_DOF_ROW_STARTS(I), WELL_DOF_ROW_STARTS(I + 1) - 1
                    C0 = 9 * INDEX
                    FV = MATRIX_W2C_VALS(C0:C0 + 8)
                    A1 = FV(0:2)
                    A2 = FV(3:5)
                    A3 = FV(6:8)
                    A11 = A11 + A1(0) * A1(0) + A1(1) * A1(1)
                    A12 = A12 + A1(0) * A2(0) + A1(1) * A2(1)                
                    A22 = A22 + A2(0) * A2(0) + A2(1) * A2(1)
                    B1 = B1 - A1(0) * A3(0) - A1(1) * A3(1)
                    B2 = B2 - A2(0) * A3(0) - A2(1) * A3(1)
                END DO
                A21 = A12
                DENOM_DET = A11 * A22 - A12 * A21
                NOM_DET = B1 * A22 - A12 * B2
                TERM(0) = NOM_DET / DENOM_DET
                NOM_DET = A11 * B2 - B1 * A21
                TERM(1) = NOM_DET / DENOM_DET
                
                IF ((DIAG(8) + TERM(0) * DIAG(2) + TERM(1) * DIAG(5)) .LT. 0.D0) THEN
                    MULT = -1.D0
                ELSE
                    MULT = 1.D0
                END IF
                C0 = 9 * I
                DO JJ = 0, 2
                    DO KK = 0, 1
                        MATRIX_W_VALS(C0 + 6 + JJ) = MATRIX_W_VALS(C0 + 6 + JJ) + TERM(KK) * MATRIX_W_VALS(C0 + 3 * KK + JJ)
                    END DO
                    MATRIX_W_VALS(C0 + 6 + JJ) = MATRIX_W_VALS(C0 + 6 + JJ) * MULT
                END DO
                DO INDEX = WELL_DOF_ROW_STARTS(I), WELL_DOF_ROW_STARTS(I + 1) - 1
                    C0 = 9 * INDEX
                    DO JJ = 0, 2
                        DO KK = 0, 1
                            MATRIX_W2C_VALS(C0 + 6 + JJ) = MATRIX_W2C_VALS(C0 + 6 + JJ) + TERM(KK) * MATRIX_W2C_VALS(C0 + 3 * KK + JJ)
                        END DO
                        MATRIX_W2C_VALS(C0 + 6 + JJ) = MATRIX_W2C_VALS(C0 + 6 + JJ) * MULT
                    END DO
                END DO
                C0 = 3 * I
                DO KK = 0, 1
                    VEC_WELL(C0 + 2) = VEC_WELL(C0 + 2) + TERM(KK) * VEC_WELL(C0 + KK)
                END DO
                VEC_WELL(C0 + 2) = VEC_WELL(C0 + 2) * MULT
            !END IF
        END DO
            !$OMP END DO
        !$OMP END PARALLEL
                
    END SUBROUTINE
    