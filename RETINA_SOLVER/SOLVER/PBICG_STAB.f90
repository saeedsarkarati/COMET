MODULE PBICG_STAB
    
    USE CRS
    USE ILU0
    IMPLICIT NONE
    
    TYPE :: PBICG_DATA
        DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: R, P, P_HAT, S, S_HAT, T, V, RR, COPY, RMIN, XMIN
    END TYPE
    
CONTAINS

    SUBROUTINE PBICG_CLEAR_(SIZE, P, P_HAT, S, S_HAT, T, V)    
        INTEGER, INTENT(IN) :: SIZE
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(OUT) :: P, P_HAT, S, S_HAT, T, V
        INTEGER :: I
        !DEC$ SIMD
        DO I = 0, SIZE - 1
            P(I) = 0.D0
            P_HAT(I) = 0.D0
            S(I) = 0.D0
            S_HAT(I) = 0.D0
            T(I) = 0.D0
            V(I) = 0.D0
        END DO
    END SUBROUTINE        
    
    SUBROUTINE PBICG_UPDATE_P_(SIZE, BETHA_I_1, OMEGA_I_1, P, R, V)
        INTEGER, INTENT(IN) :: SIZE
        DOUBLE PRECISION, INTENT(IN) :: BETHA_I_1, OMEGA_I_1
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(IN) :: R, V
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(INOUT) :: P
        INTEGER :: I
        !DEC$ SIMD
        DO I = 0, SIZE - 1
            P(I) = R(I) + BETHA_I_1 * (P(I) - OMEGA_I_1 * V(I))
        END DO        
    END SUBROUTINE
    

    SUBROUTINE PBICG_UPDATE_R_(SIZE, OMEGA_I, R, S, T)
        INTEGER, INTENT(IN) :: SIZE
        DOUBLE PRECISION, INTENT(IN) :: OMEGA_I
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(IN) :: S, T
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(OUT) :: R
        INTEGER :: I
        !DEC$ SIMD
        DO I=0, SIZE - 1
            R(I) = S(I) - OMEGA_I * T(I)
        END DO        
    END SUBROUTINE
    
    SUBROUTINE PBICG_CALC_X_(SIZE, ALPHA_I, OMEGA_I, X, P_HAT, S_HAT)
        INTEGER, INTENT(IN) :: SIZE
        DOUBLE PRECISION, INTENT(IN) :: ALPHA_I, OMEGA_I
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(IN) :: P_HAT, S_HAT
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(INOUT) :: X
        INTEGER :: I
        !DEC$ SIMD
        DO I=0, SIZE - 1
            X(I) = X(I) + ALPHA_I * P_HAT(I) + OMEGA_I * S_HAT(I)
        END DO
    END SUBROUTINE

    SUBROUTINE PBICG_CALC_X_WITHOUT_S_(SIZE, ALPHA_I, X, P_HAT)
        INTEGER, INTENT(IN) :: SIZE
        DOUBLE PRECISION, INTENT(IN) :: ALPHA_I
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(IN) :: P_HAT
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(INOUT) :: X
        INTEGER :: I
        !DEC$ SIMD
        DO I=0, SIZE - 1
            X(I) = X(I) + ALPHA_I * P_HAT(I)
        END DO
    END SUBROUTINE

    SUBROUTINE PBICG_UPDATE_S_(SIZE, ALPHA_I, S, R, V)
        INTEGER, INTENT(IN) :: SIZE
        DOUBLE PRECISION, INTENT(IN) :: ALPHA_I
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(IN) :: R, V
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(OUT) :: S
        INTEGER :: I
        !DEC$ SIMD
        DO I=0, SIZE - 1
            S(I) = R(I) - ALPHA_I * V(I)
        END DO        
    END SUBROUTINE
    
    FUNCTION PBICG_SOLVE_(SIZE, LENGTH, M_LENGTH, STARTS, INDICES, M_STARTS, M_INDICES, M_DIAG_INDICES, A, M, B, Y, X, MAX_ITER, PARAMS) RESULT(ANS)
        INTEGER, INTENT(IN) :: SIZE, LENGTH, M_LENGTH, MAX_ITER
        INTEGER, DIMENSION(0:SIZE), INTENT(IN) :: STARTS, M_STARTS
        INTEGER, DIMENSION(0:LENGTH - 1), INTENT(IN) :: INDICES
        INTEGER, DIMENSION(0:M_LENGTH - 1), INTENT(IN) :: M_INDICES
        INTEGER, DIMENSION(0:SIZE - 1), INTENT(IN) :: M_DIAG_INDICES
        DOUBLE PRECISION, DIMENSION(0:LENGTH - 1), INTENT(IN) :: A, M
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(IN) :: B
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(INOUT) :: Y, X
        INTEGER :: ANS
        TYPE(PBICG_DATA), INTENT(INOUT) :: PARAMS
        INTEGER :: I, II
        DOUBLE PRECISION :: B_NORM, S_NORM, RO_I_2, RO_I_1, ALPHA_I, ALPHA_I_1, OMEGA_I, OMEGA_I_1, BETA_I_1, R_NORM, RMIN_NORM
        LOGICAL :: CONVERGED
        CONVERGED = .FALSE.
        RO_I_1 = 0.D0
        ALPHA_I = 0.D0
        OMEGA_I = 0.D0
        BETA_I_1 = 0.D0
        CALL PBICG_CLEAR_(SIZE, PARAMS%P, PARAMS%P_HAT, PARAMS%S, PARAMS%S_HAT, PARAMS%T, PARAMS%V)
        CALL CRS_RESIDUAL_(SIZE, SIZE, LENGTH, STARTS, INDICES, A, B, X, PARAMS%R)
        RMIN_NORM = CRS_VECTOR_NORM_(SIZE, PARAMS%R)
        CALL CRS_COPY_(SIZE, PARAMS%R, PARAMS%RR)
        CALL CRS_COPY_(SIZE, PARAMS%R, PARAMS%P)
        CALL CRS_COPY_(SIZE, PARAMS%R, PARAMS%RMIN)
        CALL CRS_COPY_(SIZE, X, PARAMS%XMIN)
        B_NORM = CRS_VECTOR_NORM_(SIZE, B)
        DO I = 0, MAX_ITER - 1      
            IF (CRS_VECTOR_NORM_(SIZE, PARAMS%R) .LT. 1.D-20) THEN
                EXIT
            END IF
            CALL CRS_COPY_(SIZE, X, PARAMS%COPY)
            RO_I_2 = RO_I_1
            ALPHA_I_1 = ALPHA_I
            OMEGA_I_1 = OMEGA_I
            RO_I_1 = CRS_INNER_PRODUCT_(SIZE, PARAMS%R, PARAMS%RR)
            IF (ABS(RO_I_1) .LT. 1.D-60) THEN
                WRITE (*,*) 'PBICG_STAB FAILED'
                RETURN
            END IF
            IF (I .GT. 0) THEN
                BETA_I_1 = RO_I_1 / RO_I_2 * ALPHA_I_1 / OMEGA_I_1
                CALL PBICG_UPDATE_P_(SIZE, BETA_I_1, OMEGA_I_1, PARAMS%P, PARAMS%R, PARAMS%V)
            END IF
            CALL ILU0_TRI_SOLVE_(SIZE, M_LENGTH, M_STARTS, M_INDICES, M_DIAG_INDICES, M, PARAMS%P, PARAMS%P_HAT, Y)        
            !CALL CRS_COPY_(SIZE, PARAMS%P, PARAMS%P_HAT)
            CALL CRS_MULT_MV_(SIZE, SIZE, LENGTH, STARTS, INDICES, A, PARAMS%P_HAT, PARAMS%V)
            ALPHA_I = RO_I_1 / CRS_INNER_PRODUCT_(SIZE, PARAMS%RR, PARAMS%V)
            CALL PBICG_UPDATE_S_(SIZE, ALPHA_I, PARAMS%S, PARAMS%R, PARAMS%V)
            S_NORM = CRS_VECTOR_NORM_(SIZE, PARAMS%S)
            IF (S_NORM .LT. (1.D-12 * B_NORM)) THEN
                CALL PBICG_CALC_X_WITHOUT_S_(SIZE, ALPHA_I, X, PARAMS%P_HAT)
                EXIT
            END IF
            CALL ILU0_TRI_SOLVE_(SIZE, M_LENGTH, M_STARTS, M_INDICES, M_DIAG_INDICES, M, PARAMS%S, PARAMS%S_HAT, Y)            
            !CALL CRS_COPY_(SIZE, PARAMS%S, PARAMS%S_HAT)
            CALL CRS_MULT_MV_(SIZE, SIZE, LENGTH, STARTS, INDICES, A, PARAMS%S_HAT, PARAMS%T)
            OMEGA_I = CRS_INNER_PRODUCT_(SIZE, PARAMS%T, PARAMS%S) / CRS_INNER_PRODUCT_(SIZE, PARAMS%T, PARAMS%T)
            CALL PBICG_CALC_X_(SIZE, ALPHA_I, OMEGA_I, X, PARAMS%P_HAT, PARAMS%S_HAT)
            CALL PBICG_UPDATE_R_(SIZE, OMEGA_I, PARAMS%R, PARAMS%S, PARAMS%T)
            R_NORM = CRS_VECTOR_NORM_(SIZE, PARAMS%R)
            IF (R_NORM .LT. RMIN_NORM) THEN
                CALL CRS_COPY_(SIZE, PARAMS%R, PARAMS%RMIN)
                CALL CRS_COPY_(SIZE, X, PARAMS%XMIN)
                RMIN_NORM = R_NORM
            END IF
            IF (ABS(OMEGA_I) .LT. 1.D-60) THEN
                WRITE (*,*) 'PBICG_STAB FAILED'
                RETURN
            END IF
            
            IF (I .LT. (MAX_ITER - 1)) THEN
                IF (CRS_CONVERGED_(SIZE, X, PARAMS%COPY, 1.D-9, 1.D-12)) THEN
                    CONVERGED = .TRUE.
                    EXIT
                END IF
            END IF
        END DO
        IF (.NOT. CONVERGED) THEN
            CALL CRS_COPY_(SIZE, PARAMS%XMIN, X)
            R_NORM = RMIN_NORM
        END IF
        ANS = I + 1
    END FUNCTION

END MODULE
    