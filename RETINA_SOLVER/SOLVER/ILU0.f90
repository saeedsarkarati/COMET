MODULE ILU0

    USE CRS
    IMPLICIT NONE
    
    TYPE :: ILU_DATA
        DOUBLE PRECISION, DIMENSION(:), ALLOCATABLE :: COPY, RHS
    END TYPE
    
CONTAINS

    SUBROUTINE ILU0_INITIALIZE_(SIZE, LENGTH, STARTS, INDICES, DIAG_INDICES, VALUES, ILU_STARTS, ILU_INDICES, ILU_DIAG_INDICES, ILU)
        INTEGER, INTENT(IN) :: SIZE, LENGTH
        INTEGER, DIMENSION(0:SIZE), INTENT(IN) :: STARTS
        INTEGER, DIMENSION(0:SIZE), INTENT(OUT) :: ILU_STARTS
        INTEGER, DIMENSION(0:LENGTH - 1), INTENT(IN) :: INDICES
        INTEGER, DIMENSION(0:LENGTH - 1), INTENT(OUT) :: ILU_INDICES
        INTEGER, DIMENSION(0:SIZE - 1), INTENT(IN) :: DIAG_INDICES
        INTEGER, DIMENSION(0:SIZE - 1), INTENT(OUT) :: ILU_DIAG_INDICES
        DOUBLE PRECISION, DIMENSION(0:LENGTH - 1), INTENT(IN) :: VALUES
        DOUBLE PRECISION, DIMENSION(0:LENGTH - 1), INTENT(OUT) :: ILU
        INTEGER :: I
        !DEC$ SIMD
        DO I = 0, LENGTH - 1
            ILU(I) = VALUES(I)
            ILU_INDICES(I) = INDICES(I)
        END DO
        !DEC$ SIMD
        DO I = 0, SIZE - 1
            ILU_STARTS(I) = STARTS(I)
            ILU_DIAG_INDICES(I) = DIAG_INDICES(I)
        END DO
        ILU_STARTS(I) = STARTS(I)        
    END SUBROUTINE
    
    SUBROUTINE ILU0_CREATE_PRECONDITIONER_(SIZE, LENGTH, STARTS, INDICES, DIAG_INDICES, ILU)            
        INTEGER, INTENT(IN) :: SIZE, LENGTH
        INTEGER, DIMENSION(0:SIZE), INTENT(IN) :: STARTS
        INTEGER, DIMENSION(0:LENGTH - 1), INTENT(IN) :: INDICES
        INTEGER, DIMENSION(0:SIZE - 1), INTENT(IN) :: DIAG_INDICES
        DOUBLE PRECISION, DIMENSION(0:LENGTH - 1), INTENT(OUT) :: ILU
        INTEGER :: PIVOT, I, J_INDEX, J, I_INDEX, I_INDEX_START, J_INDEX_START, INDEX
        DOUBLE PRECISION :: PIVOT_VAL, TEMP, MULT
        
        DO PIVOT = 0, SIZE - 2             
            PIVOT_VAL = 1.D0 / ILU(DIAG_INDICES(PIVOT))
            I_INDEX_START = DIAG_INDICES(PIVOT) + 1
            DO I_INDEX = I_INDEX_START, STARTS(PIVOT + 1) - 1
                I = INDICES(I_INDEX)
                TEMP = CRS_GET_(I, PIVOT, INDEX, SIZE, LENGTH, STARTS, INDICES, ILU)
                MULT = TEMP * PIVOT_VAL
                ILU(INDEX) = MULT
                J_INDEX_START = CRS_GET_NEXT_INDEX_(I, PIVOT, SIZE, LENGTH, STARTS, INDICES)
                DO J_INDEX = J_INDEX_START, STARTS(I + 1) - 1
                    J = INDICES(J_INDEX)
                    TEMP = CRS_GET_(PIVOT, J, INDEX, SIZE, LENGTH, STARTS, INDICES, ILU)
                    ILU(J_INDEX) = ILU(J_INDEX) - MULT * TEMP
                END DO
            END DO
        END DO
        
    END SUBROUTINE
    
    SUBROUTINE ILU0_TRI_SOLVE_(SIZE, LENGTH, STARTS, INDICES, DIAG_INDICES, ILU, B, X, Y)
        INTEGER, INTENT(IN) :: SIZE, LENGTH
        INTEGER, DIMENSION(0:SIZE), INTENT(IN) :: STARTS
        INTEGER, DIMENSION(0:LENGTH - 1), INTENT(IN) :: INDICES
        INTEGER, DIMENSION(0:SIZE - 1), INTENT(IN) :: DIAG_INDICES
        DOUBLE PRECISION, DIMENSION(0:LENGTH - 1), INTENT(IN) :: ILU
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(IN) :: B
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(INOUT) :: X, Y
        INTEGER :: I, J_INDEX, J
        DOUBLE PRECISION :: SUM

        DO I = 0, SIZE - 1
            SUM = B(I)
            DO J_INDEX = STARTS(I), DIAG_INDICES(I) - 1
                J = INDICES(J_INDEX)
                SUM = SUM - ILU(J_INDEX) * X(J)
            END DO
            X(I) = SUM
        END DO        
        DO I = SIZE - 1, 0, -1
            SUM = X(I)    
            DO J_INDEX = STARTS(I + 1) - 1, DIAG_INDICES(I) + 1, -1
                J = INDICES(J_INDEX)
                SUM = SUM - ILU(J_INDEX) * Y(J)
            END DO
            Y(I) = SUM / ILU(J_INDEX)
        END DO
        !DEC$ SIMD
        DO I = 0, SIZE - 1
            X(I) = Y(I)
        END DO
    END SUBROUTINE
    
    SUBROUTINE ILU0_CALC_RHS_(SIZE, LENGTH, M_LENGTH, STARTS, INDICES, M_STARTS, M_INDICES, M_DIAG_INDICES, A, M, B, X, Y, RHS)
        ! RHS = L * U * X - A * X + B
        INTEGER, INTENT(IN) :: SIZE, LENGTH, M_LENGTH
        INTEGER, DIMENSION(0:SIZE), INTENT(IN) :: STARTS, M_STARTS
        INTEGER, DIMENSION(0:LENGTH - 1), INTENT(IN) :: INDICES
        INTEGER, DIMENSION(0:M_LENGTH - 1), INTENT(IN) :: M_INDICES
        INTEGER, DIMENSION(0:SIZE - 1), INTENT(IN) :: M_DIAG_INDICES
        DOUBLE PRECISION, DIMENSION(0:LENGTH - 1), INTENT(IN) :: A, M
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(IN) :: B, X
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(INOUT) :: Y, RHS
        INTEGER :: I, J_INDEX, J
        DOUBLE PRECISION :: SUM
        !$OMP PARALLEL
            !$OMP DO SCHEDULE(STATIC) PRIVATE(I, J_INDEX, J, SUM)            
        DO I = 0, SIZE - 1
            SUM = 0.D0            
            DO J_INDEX = M_DIAG_INDICES(I), M_STARTS(I + 1) - 1
                J = M_INDICES(J_INDEX)
                SUM = SUM + M(J_INDEX) * X(J)
            END DO
            Y(I) = SUM
        END DO
            !$OMP END DO 
        !$OMP END PARALLEL        

        !$OMP PARALLEL
            !$OMP DO SCHEDULE(STATIC) PRIVATE(I, J_INDEX, J, SUM)            
        DO I = 0, SIZE - 1
            SUM = Y(I)
            DO J_INDEX = M_STARTS(I), M_DIAG_INDICES(I) - 1
                J = M_INDICES(J_INDEX)
                SUM = SUM + M(J_INDEX) * Y(J)
            END DO
            RHS(I) = SUM
        END DO
            !$OMP END DO 
        !$OMP END PARALLEL        

        !$OMP PARALLEL
            !$OMP DO SCHEDULE(STATIC) PRIVATE(I, J_INDEX, J, SUM)            
        DO I = 0, SIZE - 1
            SUM = RHS(I) + B(I)
            DO J_INDEX = STARTS(I), STARTS(I + 1) - 1
                J = INDICES(J_INDEX)
                SUM = SUM - A(J_INDEX) * X(J)
            END DO
            RHS(I) = SUM
        END DO
            !$OMP END DO 
        !$OMP END PARALLEL        
    END SUBROUTINE
    
    FUNCTION ILU0_SOLVE_(SIZE, LENGTH, M_LENGTH, STARTS, INDICES, M_STARTS, M_INDICES, M_DIAG_INDICES, A, M, B, Y, X, MAX_ITER, PARAMS) RESULT(ANS)    
        INTEGER, INTENT(IN) :: SIZE, LENGTH, MAX_ITER, M_LENGTH
        INTEGER, DIMENSION(0:SIZE), INTENT(IN) :: STARTS, M_STARTS
        INTEGER, DIMENSION(0:LENGTH - 1), INTENT(IN) :: INDICES
        INTEGER, DIMENSION(0:M_LENGTH - 1), INTENT(IN) :: M_INDICES
        INTEGER, DIMENSION(0:SIZE - 1), INTENT(IN) :: M_DIAG_INDICES
        DOUBLE PRECISION, DIMENSION(0:LENGTH - 1), INTENT(IN) :: A, M
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(IN) :: B
        DOUBLE PRECISION, DIMENSION(0:SIZE - 1), INTENT(INOUT) :: Y, X
        TYPE(ILU_DATA), INTENT(INOUT) :: PARAMS
        INTEGER :: ANS
        DO ANS = 1, MAX_ITER
            CALL CRS_COPY_(SIZE, X, PARAMS%COPY)
            CALL ILU0_CALC_RHS_(SIZE, LENGTH, M_LENGTH, STARTS, INDICES, M_STARTS, M_INDICES, M_DIAG_INDICES, A, M, B, X, Y, PARAMS%RHS)
            CALL ILU0_TRI_SOLVE_(SIZE, M_LENGTH, M_STARTS, M_INDICES, M_DIAG_INDICES, M, PARAMS%RHS, X, Y)
            IF (ANS .LT. (MAX_ITER)) THEN
                IF (CRS_CONVERGED_(SIZE, X, PARAMS%COPY, 1.D-7, 1.D-12)) THEN
                    EXIT
                END IF
            END IF
        END DO
    END FUNCTION
    
    
    
END MODULE